generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// Survey settings for response collection
enum SurveyAccessType {
  UNLISTED     // Anyone with the link can respond
  INVITE_ONLY  // Only invited email addresses can respond
}

// Collaborator roles for team collaboration
enum CollaboratorRole {
  OWNER   // Full access, can delete survey and manage team
  EDITOR  // Can edit survey and view responses
  VIEWER  // Can only view survey and responses
}

// Survey - the main survey entity
model Survey {
  id                   String           @id @default(cuid())
  title                String
  description          String?
  published            Boolean          @default(false)
  userId               String           // Clerk user ID - survey owner
  accessType           SurveyAccessType @default(UNLISTED)
  isAnonymous          Boolean          @default(true) // If true, don't track respondent identity
  closesAt             DateTime?        // Optional deadline
  // Reminder settings
  reminderEnabled      Boolean          @default(false)
  reminderIntervalDays Int              @default(3) // Days between reminders
  reminderMaxCount     Int              @default(2) // Max reminders per invitation
  createdAt            DateTime         @default(now())
  updatedAt            DateTime         @updatedAt
  questions            Question[]
  responses            Response[]
  invitations          Invitation[]
  collaborators        SurveyCollaborator[]
  collaboratorInvites  CollaboratorInvitation[]
  webhooks             Webhook[]
  alerts               Alert[]
  // Behavioral analytics relations
  behaviorSettings     BehaviorSettings?
  sessionRecordings    SessionRecording[]
  heatmapData          HeatmapData[]

  @@index([published])
  @@index([userId])
  @@index([closesAt]) // For filtering expired surveys
}

// Invitation - tracks who has been invited to a survey
model Invitation {
  id               String    @id @default(cuid())
  surveyId         String
  survey           Survey    @relation(fields: [surveyId], references: [id], onDelete: Cascade)
  email            String
  token            String    @unique @default(cuid()) // Magic link token
  sentAt           DateTime  @default(now())
  openedAt         DateTime? // When they clicked the link
  completedAt      DateTime? // When they submitted a response
  responseId       String?   // Link to their response (if not anonymous)
  // Reminder tracking
  reminderCount    Int       @default(0) // How many reminders have been sent
  lastReminderAt   DateTime? // When the last reminder was sent
  createdAt        DateTime  @default(now())

  @@unique([surveyId, email])
  @@index([surveyId])
  @@index([token])
  @@index([email]) // For lookup by email
}

// Question types enum
enum QuestionType {
  // Text inputs
  SHORT_TEXT
  LONG_TEXT
  EMAIL
  PHONE
  NUMBER
  URL             // Website/URL input with validation
  // Date/Time
  DATE
  TIME
  // Choice questions
  SINGLE_CHOICE
  MULTIPLE_CHOICE
  DROPDOWN        // Single select dropdown (compact for many options)
  YES_NO          // Simple yes/no toggle
  IMAGE_CHOICE    // Select from image options
  // Rating/Scale questions
  RATING          // Star rating (1-5)
  SCALE           // Linear scale
  NPS             // Net Promoter Score (0-10)
  LIKERT          // Opinion scale (Strongly Disagree to Strongly Agree)
  SLIDER          // Visual slider on a range
  // Advanced questions
  MATRIX          // Grid rating - rate multiple items on same scale
  RANKING         // Drag to order items by preference
  CONSTANT_SUM    // Distribute points across options (must sum to total)
  // File & Media
  FILE_UPLOAD     // Upload files (documents, images, etc.)
  SIGNATURE       // Digital signature capture
  // Location
  ADDRESS         // Address/location input
  // Special
  HIDDEN          // Hidden field for tracking (not shown to respondent)
  // Display elements
  SECTION_HEADER  // Display-only section break (no input)
  WELCOME_SCREEN  // Introduction screen with start button
  END_SCREEN      // Thank you / completion screen
  STATEMENT       // Display-only text/info (no input required)
  LEGAL           // Consent/terms acceptance checkbox
}

// Question - individual questions in a survey
model Question {
  id          String        @id @default(cuid())
  surveyId    String
  survey      Survey        @relation(fields: [surveyId], references: [id], onDelete: Cascade)
  type        QuestionType
  title       String
  description String?
  required    Boolean       @default(false)
  order       Int
  options     Json?         // For choice questions: ["Option 1", "Option 2", ...]
  settings    Json?         // Type-specific settings (min/max for scale, etc.)
  answers     Answer[]
  // Behavioral analytics relation
  heatmapData HeatmapData[]
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  @@index([surveyId])
  @@index([order])
}

// Response - a single survey submission
model Response {
  id               String            @id @default(cuid())
  surveyId         String
  survey           Survey            @relation(fields: [surveyId], references: [id], onDelete: Cascade)
  answers          Answer[]
  respondentEmail  String?           // Only stored if survey is not anonymous
  respondentName   String?           // Only stored if survey is not anonymous
  invitationToken  String?           // If came from invitation
  completedAt      DateTime          @default(now())
  metadata         Json?             // Optional: user agent, referrer, etc.
  // Behavioral analytics relation
  sessionRecording SessionRecording?

  @@index([surveyId])
  @@index([completedAt])
  @@index([invitationToken])
  @@index([surveyId, completedAt]) // Compound index for efficient filtering
}

// Answer - individual answer to a question
model Answer {
  id         String   @id @default(cuid())
  responseId String
  response   Response @relation(fields: [responseId], references: [id], onDelete: Cascade)
  questionId String
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  value      Json     // Flexible: string, number, array of selected options, etc.
  createdAt  DateTime @default(now())

  @@index([responseId])
  @@index([questionId])
}

// Email Group - reusable lists of email recipients
model EmailGroup {
  id        String             @id @default(cuid())
  name      String             // e.g., "C-Suite", "Guild", "Contractors"
  userId    String             // Clerk user ID - group owner
  color     String?            // Optional color for UI display
  members   EmailGroupMember[]
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt

  @@unique([userId, name])
  @@index([userId])
}

// Email Group Member - individual email in a group
model EmailGroupMember {
  id        String     @id @default(cuid())
  groupId   String
  group     EmailGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)
  email     String
  name      String?    // Optional display name
  createdAt DateTime   @default(now())

  @@unique([groupId, email])
  @@index([groupId])
}

// Survey Collaborator - users with access to a survey
model SurveyCollaborator {
  id         String           @id @default(cuid())
  surveyId   String
  survey     Survey           @relation(fields: [surveyId], references: [id], onDelete: Cascade)
  userId     String           // Clerk user ID of the collaborator
  email      String           // Email for display purposes
  role       CollaboratorRole
  invitedBy  String?          // Clerk user ID of who invited them
  invitedAt  DateTime         @default(now())
  acceptedAt DateTime?        // When they accepted the invite
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt

  @@unique([surveyId, userId])
  @@unique([surveyId, email])
  @@index([surveyId])
  @@index([userId])
}

// Collaborator Invitation - pending invites to collaborate on a survey
model CollaboratorInvitation {
  id        String           @id @default(cuid())
  surveyId  String
  survey    Survey           @relation(fields: [surveyId], references: [id], onDelete: Cascade)
  email     String           // Email to invite
  role      CollaboratorRole
  token     String           @unique @default(cuid()) // Invite token
  invitedBy String           // Clerk user ID of who invited them
  expiresAt DateTime         // When the invite expires
  createdAt DateTime         @default(now())

  @@unique([surveyId, email])
  @@index([token])
  @@index([surveyId])
}

// ============================================
// AUTOMATED ALERTS & WEBHOOKS
// ============================================

// Event types that can trigger notifications
enum EventType {
  RESPONSE_SUBMITTED  // When any response is submitted
  SURVEY_COMPLETED    // When survey reaches response goal
  TRIGGER_MATCHED     // When a specific trigger condition is met
}

// Notification channels
enum NotificationChannel {
  EMAIL
  SLACK
  WEBHOOK
}

// Comparison operators for trigger conditions
enum TriggerOperator {
  EQUALS
  NOT_EQUALS
  GREATER_THAN
  LESS_THAN
  CONTAINS
  IS_EMPTY
}

// Webhook - HTTP endpoint to receive survey events
model Webhook {
  id         String            @id @default(cuid())
  surveyId   String
  survey     Survey            @relation(fields: [surveyId], references: [id], onDelete: Cascade)
  name       String            // Display name
  url        String            // Webhook URL
  secret     String?           // Optional secret for signature verification
  enabled    Boolean           @default(true)
  events     EventType[]       // Which events to send
  headers    Json?             // Custom headers to include
  createdAt  DateTime          @default(now())
  updatedAt  DateTime          @updatedAt
  deliveries WebhookDelivery[]

  @@index([surveyId])
}

// Webhook Delivery - tracks each webhook call attempt
model WebhookDelivery {
  id           String    @id @default(cuid())
  webhookId    String
  webhook      Webhook   @relation(fields: [webhookId], references: [id], onDelete: Cascade)
  eventType    EventType
  payload      Json      // What was sent
  responseCode Int?      // HTTP response status
  responseBody String?   // Response body (truncated)
  error        String?   // Error message if failed
  duration     Int?      // Request duration in ms
  deliveredAt  DateTime  @default(now())

  @@index([webhookId])
  @@index([deliveredAt])
}

// Alert - notification rule for survey events
model Alert {
  id        String              @id @default(cuid())
  surveyId  String
  survey    Survey              @relation(fields: [surveyId], references: [id], onDelete: Cascade)
  name      String              // Display name
  channel   NotificationChannel // How to notify
  enabled   Boolean             @default(true)
  config    Json                // Channel-specific config (email addresses, slack webhook URL, etc.)
  triggers  AlertTrigger[]      // Conditions that must be met
  createdAt DateTime            @default(now())
  updatedAt DateTime            @updatedAt

  @@index([surveyId])
}

// Alert Trigger - condition that triggers an alert
model AlertTrigger {
  id         String          @id @default(cuid())
  alertId    String
  alert      Alert           @relation(fields: [alertId], references: [id], onDelete: Cascade)
  questionId String          // Which question to check
  operator   TriggerOperator // Comparison operator
  value      Json            // Value to compare against

  @@index([alertId])
}

// ============================================
// BEHAVIORAL ANALYTICS (Session Recording & Heatmaps)
// ============================================

// Recording status enum
enum RecordingStatus {
  RECORDING   // Session is actively recording
  PROCESSING  // Events are being processed/compressed
  READY       // Recording is ready for playback
  FAILED      // Processing failed
  EXPIRED     // Past retention period, pending cleanup
}

// Heatmap types
enum HeatmapType {
  CLICK       // Click position heatmap
  SCROLL      // Scroll depth visualization
  MOVE        // Mouse movement heatmap
  ATTENTION   // Time-based attention map
}

// Survey-level behavior tracking settings
model BehaviorSettings {
  id               String   @id @default(cuid())
  surveyId         String   @unique
  survey           Survey   @relation(fields: [surveyId], references: [id], onDelete: Cascade)
  recordingEnabled Boolean  @default(false)
  heatmapsEnabled  Boolean  @default(false)
  consentRequired  Boolean  @default(true)
  consentText      String?  // Custom consent message
  samplingRate     Int      @default(100) // 1-100% of sessions to record
  retentionDays    Int      @default(30)  // Days to keep recordings
  maskInputs       Boolean  @default(true) // Auto-mask sensitive inputs
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
}

// Session recording metadata
model SessionRecording {
  id            String          @id @default(cuid())
  surveyId      String
  survey        Survey          @relation(fields: [surveyId], references: [id], onDelete: Cascade)
  responseId    String?         @unique
  response      Response?       @relation(fields: [responseId], references: [id], onDelete: SetNull)
  sessionToken  String          @unique @default(cuid()) // Public identifier for event upload
  duration      Int?            // Total duration in milliseconds
  eventCount    Int             @default(0)
  eventsUrl     String?         // Vercel Blob URL for event file
  deviceType    String?         // desktop, tablet, mobile
  browser       String?         // Browser name
  viewportWidth Int?
  viewportHeight Int?
  userAgent     String?
  status        RecordingStatus @default(RECORDING)
  consentGiven  Boolean         @default(false)
  startedAt     DateTime        @default(now())
  endedAt       DateTime?
  expiresAt     DateTime?       // When this recording should be deleted
  createdAt     DateTime        @default(now())

  @@index([surveyId])
  @@index([status])
  @@index([expiresAt])
  @@index([startedAt])
}

// Aggregated heatmap data (pre-computed for fast retrieval)
model HeatmapData {
  id                 String      @id @default(cuid())
  surveyId           String
  survey             Survey      @relation(fields: [surveyId], references: [id], onDelete: Cascade)
  questionId         String?
  question           Question?   @relation(fields: [questionId], references: [id], onDelete: Cascade)
  type               HeatmapType
  data               Json        // {points: [{x,y,count}], width, height, maxCount}
  viewportBreakpoint String      // "desktop", "tablet", "mobile"
  sessionCount       Int         // Number of sessions aggregated
  periodStart        DateTime    // Start of aggregation period
  periodEnd          DateTime    // End of aggregation period
  createdAt          DateTime    @default(now())
  updatedAt          DateTime    @updatedAt

  @@unique([surveyId, questionId, type, viewportBreakpoint])
  @@index([surveyId])
  @@index([questionId])
}

// ============================================
// SITE-WIDE ANALYTICS (Hotjar/Clarity-style)
// ============================================

// URL pattern matching types for page targeting
enum UrlMatchType {
  EXACT       // Exact URL match
  STARTS_WITH // URL starts with pattern
  CONTAINS    // URL contains pattern
  GLOB        // Glob pattern (e.g., /blog/*)
  REGEX       // Regular expression
}

// Survey trigger types for popup conditions
enum SurveyTriggerType {
  PAGE_LOAD     // Trigger on page load
  EXIT_INTENT   // Trigger on exit intent (mouse leaves viewport)
  SCROLL_DEPTH  // Trigger at specific scroll percentage
  TIME_ON_PAGE  // Trigger after time spent on page
  ELEMENT_CLICK // Trigger when specific element clicked
  ELEMENT_VISIBLE // Trigger when element becomes visible
}

// Survey display modes for triggered surveys
enum SurveyDisplayMode {
  POPUP       // Modal popup (center of screen)
  SLIDE_IN    // Slide in from corner
  EMBEDDED    // Embedded in page (at element)
  BANNER      // Top or bottom banner
  FULL_PAGE   // Full page takeover
}

// Site - represents a website being tracked
model Site {
  id                String   @id @default(cuid())
  userId            String   // Clerk user ID - site owner
  name              String   // Display name (e.g., "My Blog")
  domain            String   // Primary domain (e.g., "example.com")
  trackingId        String   @unique @default(cuid()) // Public ID for tracking script
  // Global settings
  recordingEnabled  Boolean  @default(true)
  heatmapsEnabled   Boolean  @default(true)
  consentRequired   Boolean  @default(true)
  consentText       String?  // Custom consent message
  samplingRate      Int      @default(100) // 1-100% of sessions to record
  retentionDays     Int      @default(30)  // Days to keep recordings
  maskInputs        Boolean  @default(true) // Auto-mask sensitive inputs
  maskSelectors     String[] @default([])  // CSS selectors to always mask
  // Status
  enabled           Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  // Relations
  pageTargets       PageTarget[]
  recordings        SiteRecording[]
  heatmapData       SiteHeatmapData[]
  surveyTriggers    SiteSurveyTrigger[]

  @@unique([userId, domain])
  @@index([userId])
  @@index([trackingId])
  @@index([domain])
}

// PageTarget - URL rules for what pages to track
model PageTarget {
  id                String       @id @default(cuid())
  siteId            String
  site              Site         @relation(fields: [siteId], references: [id], onDelete: Cascade)
  name              String       // Display name (e.g., "Blog Posts")
  urlPattern        String       // Pattern to match (e.g., "/blog/*")
  matchType         UrlMatchType @default(GLOB)
  // Override site-level settings for this page
  recordingEnabled  Boolean?     // null = inherit from site
  heatmapsEnabled   Boolean?     // null = inherit from site
  // Targeting options
  priority          Int          @default(0) // Higher priority rules match first
  enabled           Boolean      @default(true)
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt
  // Relations
  surveyTriggers    SiteSurveyTrigger[]

  @@index([siteId])
  @@index([priority])
}

// SiteSurveyTrigger - link surveys to page triggers
model SiteSurveyTrigger {
  id              String             @id @default(cuid())
  siteId          String
  site            Site               @relation(fields: [siteId], references: [id], onDelete: Cascade)
  pageTargetId    String?            // Optional - if null, applies to all pages
  pageTarget      PageTarget?        @relation(fields: [pageTargetId], references: [id], onDelete: SetNull)
  surveyId        String             // Reference to Survey model
  // Trigger configuration
  triggerType     SurveyTriggerType  @default(PAGE_LOAD)
  triggerValue    String?            // e.g., "50" for 50% scroll, "30" for 30 seconds
  triggerSelector String?            // CSS selector for ELEMENT_CLICK/ELEMENT_VISIBLE
  // Display configuration
  displayMode     SurveyDisplayMode  @default(POPUP)
  displayPosition String?            // e.g., "bottom-right" for SLIDE_IN
  displayDelay    Int                @default(0) // Additional delay in ms after trigger
  // Frequency control
  showOnce        Boolean            @default(true) // Only show once per visitor
  cooldownDays    Int                @default(7)    // Days before showing again
  percentageShow  Int                @default(100)  // % of eligible visitors to show
  // Status
  enabled         Boolean            @default(true)
  createdAt       DateTime           @default(now())
  updatedAt       DateTime           @updatedAt

  @@index([siteId])
  @@index([pageTargetId])
  @@index([surveyId])
}

// SiteRecording - site-wide session recordings
model SiteRecording {
  id              String          @id @default(cuid())
  siteId          String
  site            Site            @relation(fields: [siteId], references: [id], onDelete: Cascade)
  sessionToken    String          @unique @default(cuid()) // Public identifier for event upload
  visitorId       String          // Persistent visitor identifier
  // Page info (first page of session, can span multiple pages)
  pageUrl         String          // Full URL of first page
  pagePath        String          // Path only (e.g., "/blog/post-1")
  pageTitle       String?         // Document title
  referrer        String?         // Referrer URL
  // Device info
  deviceType      String?         // desktop, tablet, mobile
  browser         String?         // Browser name
  os              String?         // Operating system
  viewportWidth   Int?
  viewportHeight  Int?
  screenWidth     Int?
  screenHeight    Int?
  userAgent       String?
  // Location (approximate, from IP)
  country         String?
  region          String?
  city            String?
  // Session metrics
  duration        Int?            // Total duration in milliseconds
  pageCount       Int             @default(1) // Number of pages visited
  eventCount      Int             @default(0)
  eventsUrl       String?         // Vercel Blob URL for event file
  // Behavior metrics (computed from events)
  clickCount      Int             @default(0)
  scrollDepth     Int?            // Max scroll depth as percentage
  rageClicks      Int             @default(0) // Rapid clicks in same area
  deadClicks      Int             @default(0) // Clicks with no response
  uTurns          Int             @default(0) // Quick back navigation
  // Status
  status          RecordingStatus @default(RECORDING)
  consentGiven    Boolean         @default(false)
  // Survey interaction
  surveyShown     Boolean         @default(false) // Was a survey triggered?
  surveyCompleted Boolean         @default(false) // Did they complete it?
  surveyId        String?         // Which survey was shown
  // Timestamps
  startedAt       DateTime        @default(now())
  endedAt         DateTime?
  expiresAt       DateTime?       // When this recording should be deleted
  createdAt       DateTime        @default(now())

  @@index([siteId])
  @@index([visitorId])
  @@index([pagePath])
  @@index([status])
  @@index([startedAt])
  @@index([expiresAt])
  @@index([surveyId])
}

// SiteHeatmapData - aggregated heatmap data per page
model SiteHeatmapData {
  id                 String      @id @default(cuid())
  siteId             String
  site               Site        @relation(fields: [siteId], references: [id], onDelete: Cascade)
  pagePath           String      // URL path (e.g., "/about")
  pageUrl            String?     // Full URL (for reference)
  type               HeatmapType
  data               Json        // {points: [{x,y,count}], width, height, maxCount}
  viewportBreakpoint String      // "desktop", "tablet", "mobile"
  sessionCount       Int         // Number of sessions aggregated
  periodStart        DateTime    // Start of aggregation period
  periodEnd          DateTime    // End of aggregation period
  createdAt          DateTime    @default(now())
  updatedAt          DateTime    @updatedAt

  @@unique([siteId, pagePath, type, viewportBreakpoint])
  @@index([siteId])
  @@index([pagePath])
}
